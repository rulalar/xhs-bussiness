<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图片弥散效果处理器</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        .upload-section {
            text-align: center;
            margin: 20px 0;
            padding: 30px;
            border: 2px dashed #ddd;
            border-radius: 5px;
            cursor: pointer;
        }
        .upload-section:hover {
            background-color: #f9f9f9;
        }
        #file-input {
            display: none;
        }
        .preview-section {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        .original-image, .processed-image {
            flex: 1;
            min-width: 300px;
            text-align: center;
        }
        .image-container {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            margin-top: 10px;
            overflow: hidden;
            position: relative;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
            margin: 0 auto;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 5px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="range"], select {
            width: 100%;
        }
        .color-pickers {
            display: flex;
            gap: 10px;
        }
        .color-picker {
            flex: 1;
        }
        button {
            display: block;
            width: 100%;
            padding: 10px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .export-button {
            margin-top: 20px;
            background-color: #27ae60;
        }
        .export-button:hover {
            background-color: #219653;
        }
        .animation-controls {
            margin-top: 20px;
            padding: 15px;
            background: #e8f4fc;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .toggle-button {
            display: inline-block;
            width: auto;
            margin-right: 10px;
        }
        .play-pause {
            background-color: #e74c3c;
        }
        .play-pause:hover {
            background-color: #c0392b;
        }
        .play-pause.playing {
            background-color: #27ae60;
        }
        .play-pause.playing:hover {
            background-color: #219653;
        }
        .checkbox-group {
            margin: 10px 0;
        }
        .checkbox-group label {
            display: inline-flex;
            align-items: center;
            font-weight: normal;
            margin-right: 20px;
            cursor: pointer;
        }
        .checkbox-group input[type="checkbox"] {
            margin-right: 5px;
        }
        .export-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .export-option {
            flex: 1;
            min-width: 100px;
            background-color: #2980b9;
            color: white;
            padding: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 14px;
        }
        
        .export-option:hover {
            background-color: #3498db;
        }
        
        #export-jpg {
            background-color: #e74c3c;
        }
        
        #export-jpg:hover {
            background-color: #c0392b;
        }
        
        #export-png {
            background-color: #27ae60;
        }
        
        #export-png:hover {
            background-color: #2ecc71;
        }
        
        #export-webp {
            background-color: #f39c12;
        }
        
        #export-webp:hover {
            background-color: #f1c40f;
        }
        
        #export-svg {
            background-color: #8e44ad;
        }
        
        #export-svg:hover {
            background-color: #9b59b6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>图片弥散效果处理器</h1>
        
        <div class="upload-section" id="upload-area">
            <p>点击或拖拽图片到这里上传</p>
            <input type="file" id="file-input" accept="image/*">
        </div>
        
        <div class="preview-section">
            <div class="original-image">
                <h3>原始图片</h3>
                <div class="image-container">
                    <canvas id="original-canvas"></canvas>
                </div>
            </div>
            <div class="processed-image">
                <h3>处理后效果</h3>
                <div class="image-container">
                    <canvas id="processed-canvas"></canvas>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="diffusion-intensity">弥散程度：</label>
                <input type="range" id="diffusion-intensity" min="1" max="50" value="10">
                <span id="intensity-value">10</span>
            </div>
            
            <div class="control-group">
                <label for="random-scale">随机分布范围：</label>
                <input type="range" id="random-scale" min="1" max="100" value="50">
                <span id="random-scale-value">50%</span>
            </div>
            
            <div class="control-group">
                <label for="pixel-size">像素大小：</label>
                <input type="range" id="pixel-size" min="1" max="20" value="1">
                <span id="pixel-size-value">1</span>
            </div>
            
            <div class="control-group">
                <label for="coherence">连贯性：</label>
                <input type="range" id="coherence" min="0" max="100" value="30">
                <span id="coherence-value">30%</span>
            </div>
            
            <div class="control-group">
                <label>颜色偏向：</label>
                <div class="color-pickers">
                    <div class="color-picker">
                        <label for="color-influence">颜色强度：</label>
                        <input type="range" id="color-influence" min="0" max="100" value="20">
                        <span id="color-influence-value">20%</span>
                    </div>
                    <div class="color-picker">
                        <label for="color-tone">颜色选择：</label>
                        <input type="color" id="color-tone" value="#4a90e2">
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="noise-type">噪点类型：</label>
                <select id="noise-type">
                    <option value="uniform">均匀分布</option>
                    <option value="gaussian">高斯分布</option>
                    <option value="perlin">柏林噪声</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="edge-preserve">边缘保留度：</label>
                <input type="range" id="edge-preserve" min="0" max="100" value="40">
                <span id="edge-preserve-value">40%</span>
            </div>
            
            <button id="apply-effect">应用效果</button>
        </div>
        
        <div class="animation-controls">
            <h3>动态效果控制</h3>
            
            <div class="control-group">
                <button id="play-pause" class="toggle-button play-pause">播放动画</button>
                <button id="reset-animation" class="toggle-button">重置动画</button>
            </div>
            
            <div class="control-group">
                <label for="animation-speed">动画速度：</label>
                <input type="range" id="animation-speed" min="1" max="100" value="50">
                <span id="speed-value">50</span>
            </div>
            
            <div class="control-group">
                <label for="animation-type">动画类型：</label>
                <select id="animation-type">
                    <option value="oscillate">振荡</option>
                    <option value="rotate">旋转</option>
                    <option value="pulse">脉动</option>
                    <option value="flow">流动</option>
                </select>
            </div>
            
            <div class="checkbox-group">
                <label>
                    <input type="checkbox" id="auto-reverse" checked>
                    自动反转
                </label>
                <label>
                    <input type="checkbox" id="smooth-transition" checked>
                    平滑过渡
                </label>
            </div>
        </div>
        
        <button class="export-button" id="export-button">导出为JPG</button>
        <div class="export-options">
            <button class="export-option" id="export-jpg">导出JPG</button>
            <button class="export-option" id="export-png">导出PNG</button>
            <button class="export-option" id="export-webp">导出WebP</button>
            <button class="export-option" id="export-svg">导出SVG</button>
        </div>
    </div>

    <script>
        // 获取DOM元素
        const fileInput = document.getElementById('file-input');
        const uploadArea = document.getElementById('upload-area');
        const originalCanvas = document.getElementById('original-canvas');
        const processedCanvas = document.getElementById('processed-canvas');
        const diffusionIntensity = document.getElementById('diffusion-intensity');
        const intensityValue = document.getElementById('intensity-value');
        const colorInfluence = document.getElementById('color-influence');
        const colorInfluenceValue = document.getElementById('color-influence-value');
        const colorTone = document.getElementById('color-tone');
        const applyEffectBtn = document.getElementById('apply-effect');
        const exportBtn = document.getElementById('export-button');
        
        // 新增控制元素
        const randomScale = document.getElementById('random-scale');
        const randomScaleValue = document.getElementById('random-scale-value');
        const pixelSize = document.getElementById('pixel-size');
        const pixelSizeValue = document.getElementById('pixel-size-value');
        const coherence = document.getElementById('coherence');
        const coherenceValue = document.getElementById('coherence-value');
        const noiseType = document.getElementById('noise-type');
        const edgePreserve = document.getElementById('edge-preserve');
        const edgePreserveValue = document.getElementById('edge-preserve-value');

        // 动画控制元素
        const playPauseBtn = document.getElementById('play-pause');
        const resetAnimationBtn = document.getElementById('reset-animation');
        const animationSpeed = document.getElementById('animation-speed');
        const speedValue = document.getElementById('speed-value');
        const animationType = document.getElementById('animation-type');
        const autoReverse = document.getElementById('auto-reverse');
        const smoothTransition = document.getElementById('smooth-transition');

        // 原始图像数据
        let originalImage = null;
        
        // 动画相关变量
        let animationId = null;
        let isPlaying = false;
        let animationPhase = 0;
        let baseIntensity = 10;
        let animationDirection = 1;
        
        // 监听上传区域点击
        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });
        
        // 监听拖拽事件
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#3498db';
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.style.borderColor = '#ddd';
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#ddd';
            
            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleImageUpload(e.dataTransfer.files[0]);
            }
        });
        
        // 监听文件选择
        fileInput.addEventListener('change', (e) => {
            if (fileInput.files.length) {
                handleImageUpload(fileInput.files[0]);
            }
        });
        
        // 处理图片上传
        function handleImageUpload(file) {
            if (!file.type.match('image.*')) {
                alert('请上传图片文件！');
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = (e) => {
                originalImage = new Image();
                originalImage.onload = () => {
                    // 绘制原始图像
                    drawOriginalImage();
                    // 应用初始效果
                    applyEffect();
                };
                originalImage.src = e.target.result;
            };
            
            reader.readAsDataURL(file);
        }
        
        // 绘制原始图像
        function drawOriginalImage() {
            const ctx = originalCanvas.getContext('2d');
            
            // 调整画布大小以保持图像比例
            const containerWidth = originalCanvas.parentElement.offsetWidth;
            const containerHeight = originalCanvas.parentElement.offsetHeight;
            
            const scale = Math.min(
                containerWidth / originalImage.width,
                containerHeight / originalImage.height
            );
            
            const width = originalImage.width * scale;
            const height = originalImage.height * scale;
            
            originalCanvas.width = width;
            originalCanvas.height = height;
            processedCanvas.width = width;
            processedCanvas.height = height;
            
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(originalImage, 0, 0, width, height);
        }
        
        // 应用弥散效果
        function applyEffect(animParams = {}) {
            if (!originalImage) {
                alert('请先上传图片！');
                return;
            }
            
            const originalCtx = originalCanvas.getContext('2d');
            const processedCtx = processedCanvas.getContext('2d');
            
            const width = originalCanvas.width;
            const height = originalCanvas.height;
            
            // 获取原始图像数据
            const imageData = originalCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // 创建一个新的 ImageData 对象以存储处理后的图像
            const processedImageData = processedCtx.createImageData(width, height);
            const processedData = processedImageData.data;
            
            // 复制原始数据
            for (let i = 0; i < data.length; i++) {
                processedData[i] = data[i];
            }
            
            // 获取参数值
            let intensity = parseInt(diffusionIntensity.value);
            let rScale = parseInt(randomScale.value) / 100;
            let pSize = parseInt(pixelSize.value);
            let coh = parseInt(coherence.value) / 100;
            let edgeP = parseInt(edgePreserve.value) / 100;
            let nType = noiseType.value;
            
            // 如果是动画模式，调整强度
            if (animParams.animated) {
                // 根据动画类型调整动画参数
                switch (animationType.value) {
                    case 'oscillate':
                        intensity = intensity * (1 + Math.sin(animParams.phase) * 0.5);
                        break;
                    case 'pulse':
                        intensity = intensity * (1 + Math.abs(Math.sin(animParams.phase)) * 0.7);
                        break;
                    case 'rotate':
                        // 旋转动画保留原始强度，但会改变相位
                        break;
                    case 'flow':
                        intensity = intensity * (1 + Math.cos(animParams.phase * 0.5) * 0.3);
                        break;
                }
            }
            
            const colorInf = parseInt(colorInfluence.value) / 100;
            
            // 解析颜色
            const hex = colorTone.value.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            // 应用随机弥散效果
            enhancedRandomDiffusion(processedData, width, height, intensity, colorInf, r, g, b, animParams, {
                randomScale: rScale,
                pixelSize: pSize,
                coherence: coh,
                noiseType: nType,
                edgePreserve: edgeP
            });
            
            // 将处理后的数据绘制到画布上
            processedCtx.putImageData(processedImageData, 0, 0);
        }
        
        // 使用柏林噪声辅助函数
        function generatePerlinNoise(x, y, z) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;
            
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            
            const u = fade(x);
            const v = fade(y);
            const w = fade(z);
            
            const p = new Array(512);
            for (let i = 0; i < 256; i++) p[i] = p[i + 256] = Math.floor(Math.random() * 256);
            
            const A = p[X] + Y;
            const AA = p[A] + Z;
            const AB = p[A + 1] + Z;
            const B = p[X + 1] + Y;
            const BA = p[B] + Z;
            const BB = p[B + 1] + Z;
            
            return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),
                                  grad(p[BA], x - 1, y, z)),
                         lerp(u, grad(p[AB], x, y - 1, z),
                              grad(p[BB], x - 1, y - 1, z))),
               lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1),
                            grad(p[BA + 1], x - 1, y, z - 1)),
                    lerp(u, grad(p[AB + 1], x, y - 1, z - 1),
                         grad(p[BB + 1], x - 1, y - 1, z - 1))));
        }

        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        function lerp(t, a, b) {
            return a + t * (b - a);
        }

        function grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        // 增强的随机弥散效果
        function enhancedRandomDiffusion(data, width, height, intensity, colorInf, r, g, b, animParams = {}, options = {}) {
            const temp = new Uint8ClampedArray(data.length);
            for (let i = 0; i < data.length; i++) {
                temp[i] = data[i];
            }
            
            // 从选项中获取参数
            const randomScale = options.randomScale || 0.5;
            const pixelSize = options.pixelSize || 1;
            const coherence = options.coherence || 0.3;
            const noiseType = options.noiseType || 'uniform';
            const edgePreserve = options.edgePreserve || 0.4;
            
            // 使用相位作为随机种子
            const phase = animParams.animated ? animParams.phase : 0;
            
            // 检测边缘 - 使用简单的Sobel算子
            const edgeMap = new Float32Array(width * height);
            if (edgePreserve > 0) {
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // 水平和垂直梯度的简化Sobel算子
                        const gx = 
                              -1 * temp[((y-1)*width + (x-1))*4] +
                              1 * temp[((y-1)*width + (x+1))*4] +
                              -2 * temp[((y)*width + (x-1))*4] +
                              2 * temp[((y)*width + (x+1))*4] +
                              -1 * temp[((y+1)*width + (x-1))*4] +
                              1 * temp[((y+1)*width + (x+1))*4];
                        
                        const gy = 
                              -1 * temp[((y-1)*width + (x-1))*4] +
                              -2 * temp[((y-1)*width + (x))*4] +
                              -1 * temp[((y-1)*width + (x+1))*4] +
                              1 * temp[((y+1)*width + (x-1))*4] +
                              2 * temp[((y+1)*width + (x))*4] +
                              1 * temp[((y+1)*width + (x+1))*4];
                        
                        // 边缘强度
                        edgeMap[y * width + x] = Math.sqrt(gx*gx + gy*gy) / 1024;
                    }
                }
            }
            
            // 创建一个伪随机函数，使动画在相同相位时产生相同的随机值
            const pseudoRandom = (x, y) => {
                return Math.sin(x * 12.9898 + y * 78.233 + phase) * 43758.5453 % 1;
            };
            
            // 高斯分布随机数
            const gaussianRandom = () => {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            };
            
            // 根据不同的噪点类型生成随机偏移
            const generateOffset = (x, y, pixelGroup) => {
                // 为了保持连贯性，相同像素组使用相同的随机偏移
                if (coherence > 0) {
                    x = Math.floor(x / pixelSize) * pixelSize;
                    y = Math.floor(y / pixelSize) * pixelSize;
                }
                
                switch (noiseType) {
                    case 'gaussian':
                        return {
                            x: gaussianRandom() * intensity * randomScale,
                            y: gaussianRandom() * intensity * randomScale
                        };
                    case 'perlin':
                        return {
                            x: generatePerlinNoise(x/width * 5, y/height * 5, phase) * intensity * 2 * randomScale,
                            y: generatePerlinNoise(y/height * 5, x/width * 5, phase+10) * intensity * 2 * randomScale
                        };
                    default: // uniform
                        return {
                            x: (pseudoRandom(x, y) - 0.5) * intensity * 2 * randomScale,
                            y: (pseudoRandom(y, x) - 0.5) * intensity * 2 * randomScale
                        };
                }
            };
            
            // 处理图像，按像素组进行处理
            for (let py = 0; py < Math.ceil(height / pixelSize); py++) {
                for (let px = 0; px < Math.ceil(width / pixelSize); px++) {
                    // 为这个像素组生成一个随机偏移
                    const groupOffset = generateOffset(px*pixelSize, py*pixelSize, { px, py });
                    
                    // 处理这个像素组中的所有像素
                    for (let dy = 0; dy < pixelSize && py*pixelSize+dy < height; dy++) {
                        for (let dx = 0; dx < pixelSize && px*pixelSize+dx < width; dx++) {
                            const x = px * pixelSize + dx;
                            const y = py * pixelSize + dy;
                            const index = (y * width + x) * 4;
                            
                            // 边缘检测 - 如果是边缘，减少偏移量
                            let edgeFactor = 1;
                            if (edgePreserve > 0 && x > 0 && x < width-1 && y > 0 && y < height-1) {
                                edgeFactor = 1 - Math.min(1, edgeMap[y * width + x] * edgePreserve * 5);
                            }
                            
                            // 计算最终偏移
                            let offsetX = groupOffset.x * edgeFactor;
                            let offsetY = groupOffset.y * edgeFactor;
                            
                            // 对于非连贯性部分，添加一些完全随机的偏移
                            if (coherence < 1) {
                                const randomFactor = 1 - coherence;
                                const individualOffset = generateOffset(x, y, null);
                                offsetX = offsetX * coherence + individualOffset.x * randomFactor;
                                offsetY = offsetY * coherence + individualOffset.y * randomFactor;
                            }
                            
                            const newX = Math.floor(x + offsetX);
                            const newY = Math.floor(y + offsetY);
                            
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                                const targetIndex = (newY * width + newX) * 4;
                                
                                // 混合颜色
                                data[index] = Math.round(temp[targetIndex] * (1 - colorInf) + r * colorInf);
                                data[index + 1] = Math.round(temp[targetIndex + 1] * (1 - colorInf) + g * colorInf);
                                data[index + 2] = Math.round(temp[targetIndex + 2] * (1 - colorInf) + b * colorInf);
                            }
                        }
                    }
                }
            }
        }
        
        // 动画循环
        function animateEffect() {
            if (!originalImage) return;
            
            // 更新动画相位
            animationPhase += 0.05 * (parseInt(animationSpeed.value) / 50);
            
            // 如果启用了自动反转，检查是否需要反转方向
            if (autoReverse.checked) {
                if (animationPhase > Math.PI * 2) {
                    animationDirection = -1;
                } else if (animationPhase < 0) {
                    animationDirection = 1;
                }
                animationPhase += 0.05 * (parseInt(animationSpeed.value) / 50) * animationDirection;
            } else {
                // 否则在完成一个循环后重置
                if (animationPhase > Math.PI * 2) {
                    animationPhase = 0;
                }
            }
            
            // 应用动画效果
            applyEffect({
                animated: true,
                phase: animationPhase,
                smooth: smoothTransition.checked
            });
            
            // 继续动画循环
            animationId = requestAnimationFrame(animateEffect);
        }
        
        // 播放/暂停动画
        function toggleAnimation() {
            if (isPlaying) {
                // 暂停动画
                cancelAnimationFrame(animationId);
                playPauseBtn.textContent = '播放动画';
                playPauseBtn.classList.remove('playing');
            } else {
                // 开始动画
                animationId = requestAnimationFrame(animateEffect);
                playPauseBtn.textContent = '暂停动画';
                playPauseBtn.classList.add('playing');
            }
            
            isPlaying = !isPlaying;
        }
        
        // 重置动画
        function resetAnimation() {
            animationPhase = 0;
            animationDirection = 1;
            
            if (isPlaying) {
                // 如果正在播放，应用最新效果
                applyEffect({
                    animated: true,
                    phase: 0,
                    smooth: smoothTransition.checked
                });
            } else {
                // 如果已暂停，应用静态效果
                applyEffect();
            }
        }
        
        // 监听滑块变化并更新显示值
        diffusionIntensity.addEventListener('input', () => {
            intensityValue.textContent = diffusionIntensity.value;
            baseIntensity = parseInt(diffusionIntensity.value);
            if (!isPlaying) {
                applyEffect();
            }
        });
        
        colorInfluence.addEventListener('input', () => {
            colorInfluenceValue.textContent = `${colorInfluence.value}%`;
            if (!isPlaying) {
                applyEffect();
            }
        });
        
        // 新增控制元素的监听器
        randomScale.addEventListener('input', () => {
            randomScaleValue.textContent = `${randomScale.value}%`;
            if (!isPlaying) {
                applyEffect();
            }
        });

        pixelSize.addEventListener('input', () => {
            pixelSizeValue.textContent = pixelSize.value;
            if (!isPlaying) {
                applyEffect();
            }
        });

        coherence.addEventListener('input', () => {
            coherenceValue.textContent = `${coherence.value}%`;
            if (!isPlaying) {
                applyEffect();
            }
        });

        noiseType.addEventListener('change', () => {
            if (!isPlaying) {
                applyEffect();
            }
        });

        edgePreserve.addEventListener('input', () => {
            edgePreserveValue.textContent = `${edgePreserve.value}%`;
            if (!isPlaying) {
                applyEffect();
            }
        });
        
        animationSpeed.addEventListener('input', () => {
            speedValue.textContent = animationSpeed.value;
        });
        
        // 监听颜色选择和弥散方法变化
        colorTone.addEventListener('change', () => {
            if (!isPlaying) {
                applyEffect();
            }
        });
        
        // 监听动画类型变化
        animationType.addEventListener('change', () => {
            if (isPlaying) {
                resetAnimation();
            }
        });
        
        // 监听应用效果按钮点击
        applyEffectBtn.addEventListener('click', () => {
            applyEffect();
        });
        
        // 监听动画控制按钮
        playPauseBtn.addEventListener('click', toggleAnimation);
        resetAnimationBtn.addEventListener('click', resetAnimation);
        
        // 添加导出按钮的事件监听器
        const exportJpgBtn = document.getElementById('export-jpg');
        const exportPngBtn = document.getElementById('export-png');
        const exportWebpBtn = document.getElementById('export-webp');
        const exportSvgBtn = document.getElementById('export-svg');

        // 修改导出为JPG
        exportBtn.addEventListener('click', () => exportImage('jpeg'));
        exportJpgBtn.addEventListener('click', () => exportImage('jpeg'));
        exportPngBtn.addEventListener('click', () => exportImage('png'));
        exportWebpBtn.addEventListener('click', () => exportImage('webp'));
        exportSvgBtn.addEventListener('click', () => exportImage('svg'));

        // 统一导出函数
        function exportImage(format) {
            if (!originalImage) {
                alert('请先上传并处理图片！');
                return;
            }
            
            // 确认导出分辨率选项
            const qualityOptions = ['原始尺寸', '2倍超分辨率', '4倍超分辨率', '自定义尺寸'];
            let selectedOption = prompt(
                '请选择导出图片的分辨率:\n1: 原始尺寸\n2: 2倍超分辨率\n3: 4倍超分辨率\n4: 自定义尺寸\n(输入选项编号)',
                '1'
            );
            
            // 设置输出尺寸
            let outputWidth = originalImage.width;
            let outputHeight = originalImage.height;
            
            // 处理用户选择
            if (selectedOption === '2') {
                // 2倍超分辨率
                outputWidth = originalImage.width * 2;
                outputHeight = originalImage.height * 2;
            } else if (selectedOption === '3') {
                // 4倍超分辨率
                outputWidth = originalImage.width * 4;
                outputHeight = originalImage.height * 4;
            } else if (selectedOption === '4') {
                // 自定义尺寸
                const customWidth = parseInt(prompt('请输入宽度(像素):', originalImage.width));
                const customHeight = parseInt(prompt('请输入高度(像素):', originalImage.height));
                if (!isNaN(customWidth) && !isNaN(customHeight) && customWidth > 0 && customHeight > 0) {
                    outputWidth = customWidth;
                    outputHeight = customHeight;
                }
            }
            
            // 创建高质量渲染流程
            const enhancementLevel = parseInt(prompt('请选择清晰度增强级别 (1-5，5为最高):', '3'));
            
            try {
                // 创建一个临时画布，使用设定的输出尺寸
                const outputCanvas = document.createElement('canvas');
                outputCanvas.width = outputWidth;
                outputCanvas.height = outputHeight;
                const outputCtx = outputCanvas.getContext('2d');
                
                // 设置高质量渲染选项
                outputCtx.imageSmoothingEnabled = true;
                outputCtx.imageSmoothingQuality = 'high';
                
                // 简化的处理流程 - 直接使用已经渲染好的画布内容
                // 这确保导出的图像与用户看到的预览完全一致
                
                // 1. 创建中间画布，保存当前效果
                const intermediateCanvas = document.createElement('canvas');
                intermediateCanvas.width = processedCanvas.width;
                intermediateCanvas.height = processedCanvas.height;
                const intermediateCtx = intermediateCanvas.getContext('2d');
                
                // 复制当前处理后的效果到中间画布
                intermediateCtx.drawImage(processedCanvas, 0, 0);
                
                // 2. 将中间画布内容直接缩放到输出画布
                outputCtx.drawImage(intermediateCanvas, 0, 0, intermediateCanvas.width, intermediateCanvas.height,
                                  0, 0, outputWidth, outputHeight);
                
                // 仅当用户请求增强时应用锐化
                if (enhancementLevel > 1) {
                    // 应用锐化以提高缩放后的清晰度
                    for (let i = 0; i < enhancementLevel - 1; i++) {
                        applySharpening(outputCtx, outputWidth, outputHeight);
                    }
                }
                
                // 创建临时链接以下载
                const link = document.createElement('a');
                let mimeType, quality;
                
                switch(format) {
                    case "png":
                        mimeType = "image/png";
                        link.download = `处理后图片_${outputWidth}x${outputHeight}.png`;
                        link.href = outputCanvas.toDataURL(mimeType);
                        break;
                    case "webp":
                        mimeType = "image/webp";
                        quality = 0.95;
                        link.download = `处理后图片_${outputWidth}x${outputHeight}.webp`;
                        link.href = outputCanvas.toDataURL(mimeType, quality);
                        break;
                    case "svg":
                        // SVG导出
                        link.download = `处理后图片_${outputWidth}x${outputHeight}.svg`;
                        
                        // SVG特定设置
                        let svgComplexity = "2"; // 默认中等复杂度
                        if (outputWidth > 500 || outputHeight > 500) {
                            svgComplexity = prompt("SVG复杂度级别:\n1: 低 (文件小，细节少)\n2: 中 (平衡)\n3: 高 (文件大，细节多)\n输入数字:", "2");
                        }
                        
                        const renderMethod = prompt("选择SVG渲染方式:\n1: 路径 (更适合艺术效果)\n2: 矩形 (更简单的表示)\n输入数字:", "1");
                        
                        // 获取SVG内容
                        const svgContent = generateSVG(outputCanvas, outputWidth, outputHeight, svgComplexity, renderMethod);
                        const svgBlob = new Blob([svgContent], {type: 'image/svg+xml'});
                        link.href = URL.createObjectURL(svgBlob);
                        break;
                    default: // jpeg
                        mimeType = "image/jpeg";
                        quality = 0.95; // 提高JPEG质量
                        link.download = `处理后图片_${outputWidth}x${outputHeight}.jpg`;
                        link.href = outputCanvas.toDataURL(mimeType, quality);
                }
                
                // 开始下载
                link.click();
                
                // 如果创建了Blob URL，需要释放
                if (format === 'svg') {
                    URL.revokeObjectURL(link.href);
                }
                
                // 提示用户处理完成
                alert(`图片导出成功！\n分辨率: ${outputWidth}x${outputHeight}\n格式: ${format.toUpperCase()}`);
            } catch (error) {
                console.error("导出过程中出错:", error);
                alert("导出图片时出现错误，请尝试降低分辨率或刷新页面后重试。");
            }
        }
        
        // 生成SVG
        function generateSVG(canvas, width, height, svgComplexity = "2", renderMethod = "1") {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // 根据复杂度确定采样率
            let samplingRate;
            switch(svgComplexity) {
                case "1": samplingRate = Math.max(Math.ceil(width / 100), Math.ceil(height / 100)); break;
                case "3": samplingRate = 1; break;
                default: samplingRate = Math.max(Math.ceil(width / 200), Math.ceil(height / 200));
            }
            
            // 构建SVG标题和背景
            let svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
    <rect width="100%" height="100%" fill="white"/>
`;
            
            if (renderMethod === "1") {
                // 路径方法：使用颜色分组，为每组颜色创建一个路径
                const colorPaths = {};
                
                // 处理每个像素
                for (let y = 0; y < height; y += samplingRate) {
                    for (let x = 0; x < width; x += samplingRate) {
                        const index = (y * width + x) * 4;
                        const r = data[index];
                        const g = data[index + 1];
                        const b = data[index + 2];
                        const a = data[index + 3] / 255;
                        
                        if (a < 0.1) continue; // 跳过透明像素
                        
                        // 颜色量化，减少颜色数量
                        const quantizationFactor = svgComplexity === "1" ? 32 : (svgComplexity === "2" ? 16 : 8);
                        const qR = Math.round(r / quantizationFactor) * quantizationFactor;
                        const qG = Math.round(g / quantizationFactor) * quantizationFactor;
                        const qB = Math.round(b / quantizationFactor) * quantizationFactor;
                        
                        const color = `rgba(${qR},${qG},${qB},${a.toFixed(2)})`;
                        
                        if (!colorPaths[color]) {
                            colorPaths[color] = [];
                        }
                        
                        colorPaths[color].push({x, y});
                    }
                }
                
                // 将像素转换为SVG路径
                for (const color in colorPaths) {
                    const points = colorPaths[color];
                    
                    // 检查是否有足够的点
                    if (points.length === 0) continue;
                    
                    // 创建路径
                    let d = `M ${points[0].x} ${points[0].y} `;
                    for (let i = 1; i < points.length; i++) {
                        // 根据点的密度使用不同的路径命令
                        if (i % 100 === 0) {
                            // 每100个点使用一次移动命令，以防路径过长
                            d += `M ${points[i].x} ${points[i].y} `;
                        } else {
                            d += `L ${points[i].x} ${points[i].y} `;
                        }
                    }
                    
                    svg += `    <path d="${d}" fill="${color}" stroke="none" />
`;
                }
            } else {
                // 矩形方法：为每个像素创建一个小矩形
                for (let y = 0; y < height; y += samplingRate) {
                    for (let x = 0; x < width; x += samplingRate) {
                        const index = (y * width + x) * 4;
                        const r = data[index];
                        const g = data[index + 1];
                        const b = data[index + 2];
                        const a = data[index + 3] / 255;
                        
                        if (a < 0.1) continue; // 跳过透明像素
                        
                        // 颜色量化，减少SVG大小
                        const quantizationFactor = svgComplexity === "1" ? 32 : (svgComplexity === "2" ? 16 : 8);
                        const qR = Math.round(r / quantizationFactor) * quantizationFactor;
                        const qG = Math.round(g / quantizationFactor) * quantizationFactor;
                        const qB = Math.round(b / quantizationFactor) * quantizationFactor;
                        
                        svg += `    <rect x="${x}" y="${y}" width="${samplingRate}" height="${samplingRate}" fill="rgba(${qR},${qG},${qB},${a.toFixed(2)})" />
`;
                    }
                }
            }
            
            // 关闭SVG标签
            svg += '</svg>';
            
            return svg;
        }
        
        // 锐化处理函数 - 简化版本
        function applySharpening(ctx, width, height) {
            try {
                // 获取图像数据
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                // 创建一个临时数组来存储处理后的数据
                const tempData = new Uint8ClampedArray(data);
                
                // 使用简单的锐化卷积核
                const kernel = [
                    0, -0.5, 0,
                    -0.5, 3, -0.5,
                    0, -0.5, 0
                ];
                
                // 应用卷积
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        // 对每个颜色通道分别应用卷积
                        for (let c = 0; c < 3; c++) {  // 只处理RGB通道，不处理Alpha
                            const index = (y * width + x) * 4 + c;
                            
                            // 应用卷积
                            let sum = 0;
                            for (let ky = -1; ky <= 1; ky++) {
                                for (let kx = -1; kx <= 1; kx++) {
                                    const kernelIndex = (ky + 1) * 3 + (kx + 1);
                                    const pixelIndex = ((y + ky) * width + (x + kx)) * 4 + c;
                                    
                                    if (pixelIndex >= 0 && pixelIndex < data.length) {
                                        sum += data[pixelIndex] * kernel[kernelIndex];
                                    }
                                }
                            }
                            
                            // 确保值在0-255范围内
                            tempData[index] = Math.min(255, Math.max(0, sum));
                        }
                    }
                }
                
                // 将处理后的数据放回画布
                ctx.putImageData(new ImageData(tempData, width, height), 0, 0);
            } catch (error) {
                console.error("锐化处理出错:", error);
                // 错误时不应用锐化，继续使用原图
            }
        }
    </script>
</body>
</html> 